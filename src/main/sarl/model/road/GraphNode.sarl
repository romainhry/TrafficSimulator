package model
import java.util.ArrayList

class GraphNode {
	var neighbourNodes : ArrayList<GraphNode> // Nodes where i can move to
	var conflictNodesInFront : ArrayList<GraphNode>
	var conflictNodesInBack : ArrayList<GraphNode>
	/* Nodes that may cause a problem, so i need to have a perception of them
	 */
	var frontNeighbourNodes : ArrayList<GraphNode> //Neighbours in front of this node
	var backNeighbourNodes : ArrayList<GraphNode> //Neighbours behind this node
	var length : float // length of the node (dah)
	var posObj : ArrayList<PositionedObjects> // Objects in it
	var maxDesviationRight : float // Max desviation i can have to the right
	var maxDesviationLeft : float // Max desviation i can have to the left
	var isFinalNode : boolean //end of the route
	var isStartPoint = false //begin of the route
	
	new (l : float, b : boolean){
		this.length=l
		this.isFinalNode=b
	}
	new(l : float, b : boolean, ini : boolean) {
		this.length = l
		this.isFinalNode = b
		this.isStartPoint = b
	}

	def itIsEmptyNode() : Boolean {
		if (posObj.empty) {
			return true
		} else {
			return false
		}
	}

	def itHasNeighbour() {
		if (neighbourNodes.empty) {
			return false
		} else {
			return true
		}
	}

	def itHasConflictNodesInFront() {
		if (conflictNodesInFront.empty) {
			return true
		} else {
			return false
		}
	}

	def itHasConflictNodesInBack() {
		if (conflictNodesInBack.empty) {
			return true
		} else {
			return false
		}
	}

	def itHasFrontNeighbour() {
		if (frontNeighbourNodes.empty) {
			return false
		} else {
			return true
		}
	}

	def itHasBackNeighbour() {
		if (backNeighbourNodes.empty) {
			return false
		} else {
			return true
		}
	}

	def isNeighbour(node : GraphNode) : Boolean {
		for (n : neighbourNodes) {
			if (n == node) {
				return true
			}
		}
		return false
	}

	def add(node : GraphNode) {
		neighbourNodes.add(node)
		node.neighbourNodes.add(this)
	}

	def addFrontNeighbour(node : GraphNode) {
		frontNeighbourNodes.add(node)
		node.backNeighbourNodes.add(this)
	}

	def addBackNeighbour(node : GraphNode) {
		backNeighbourNodes.add(node)
		node.frontNeighbourNodes.add(this)
	}

	def addConflictFrontNeighbour(node : GraphNode) {
		conflictNodesInFront.add(node)
		node.conflictNodesInBack.add(this)
	}

	def addConflictBackNeighbour(node : GraphNode) {
		conflictNodesInBack.add(node)
		node.conflictNodesInFront.add(this)
	}
	

	def isEmptyAt(x : float, len : float) : Boolean {
				/* We need to know if the node is empty at a particular coordinate (x)
			 * and with his proximities (len)
			 */
		for (o : posObj) {
			if (o.position.x + o.length < x + len && o.position.x + o.length > x - len) {
				return false
			}
			if (o.position.x - o.length < x + len && o.position.x - o.length > x - len) {
				return false
			}
			if (o.position.x + o.length > x + len && o.position.x - o.length < x - len) {
				return false
			}
			return true
		}
	}
	def objectAt(x : float) : PositionedObjects { /*We need to know if there is an object
	 * at a given position*/
		for (o : posObj) {
			if (o.position.x - o.length <= x && x <= o.position.x + o.position.x) {
				return o
			}
		}
		return null
	}
	def getPosObj : ArrayList<PositionedObjects> {
		return this.posObj
	}
	def getLength : float {
		return this.length
	}

	def getFrontNeighbourNodes : ArrayList<GraphNode> {
		return this.frontNeighbourNodes
	}

	def getBackNeighbourNodes : ArrayList<GraphNode> {
		return this.backNeighbourNodes
	}

	def getConflictNodesInFront : ArrayList<GraphNode> {
		return this.conflictNodesInFront
	}

	def getConflictNodesInBack : ArrayList<GraphNode> {
		return this.conflictNodesInBack
	}
	def nextNode(n : int) : GraphNode{
		return this.frontNeighbourNodes.get(n)
	}
}
